---
title: Facade 패턴
tags:
  - 디자인패턴
  - 구조패턴
---

> 작성자 : 김동섭

<!--more-->

<hr>

원본자료 - [Refactoring Guru](https://refactoring.guru/design-patterns/facade)

# Facade
## 설명
- Facade는 복잡한 클래스들이나 라이브러리, 프레임워크에게 간단한 인터페이스를 제공하는 디자인 패턴입니다.

## 문제
- 내가 사용하는 코드가 제 3의 라이브러리나 프레임워크에 속하는 객체들을 사용해야하는 상황.
- 보통이라면, 그런 객체들을 선언하고 생성하며, 의존성들을 하나하나 확인하며 구현해야함.
- 결론적으로, 실제로 구현해야하는 비지니스 로직이 제3의 라이브러리나 프레임워크에 강하게 결합돼 유지보수가 힘들어진다.

## 해결책
- Facade는 구성 부품들이 많은 복잡한 시스템에게 간단한 인터페이스를 제공하는 클래스입니다.
- Facade는 시스템을 직접적으로 사용하는 것에 비해서는 제한된 기능을 제공할 수 있지만, 클라이언트가 진짜로 관심있어 하는 기능들만 포함합니다.
- Facade는 앱을 매우 복잡하고 기능이 많은 라이브러리와 연동해야 하는데 그 라이브러리의 아주 작은 부분만 필요할 때 유용합니다.
	- 예를들어, 앱이 짧은 비디오를 업로드하는 기능을 가지고 있는데, 업로드시 매우 복잡한 비디오 전환 라이브러리를 사용할 수 있습니다. 
	- 그러나 앱이 진짜로 필요한 것은 `encode(filename, format)`이라는 함수 하나만 가진 클래스라면
	- 그 클래스를 생성한 후 비디오 전환 라이브러리와 연결한 한다면, Facade가 생성됩니다.

## 실세상 비유
- 홈쇼핑을 주문하려고 전화를 하면, 상담원이 상품판매shop의 모든 서비스와 부서들의 facade입니다. 상담원은 주문, 결제, 배달에 대한 simple voice interface입니다.

## 구조
![Screen Shot 2021-08-06 at 4.30.46 PM.png](https://res.cloudinary.com/ddeivviyp/image/upload/v1628238892/MyBlog/kgnzbmltj2aw8xpud3iu.png)
1. Facade는 서브시스템 기능의 특정 부분에 대한 간편한 접근을 제공합니다. Facade는 클라이언트의 요청을 어디로 보내야 할지 알고 있고, 서브시스템을 동작시키는 방법을 알고 있습니다. 
2. Additional Facade 클래스는 하나의 Facade 클래스에 너무 많은, 혹은 필요 없는 기능이 몰려서 또다른 복잡한 시스템을 만드는 것을 방지하기 위해 생성됩니다. Additional Facade는 클라이언트나 다른 Facade에서 사용될 수 있습니다. 
3. Complex Subsystem은 많고 다양한 객체들로 구성되어 있습니다. 모든 구성요소들이 의미있는 행동을 하게 하려면, 서브시스템 안으로 깊숙히 들어가 작성된 코드들을 뜯어보고, 올바른 순서대로 함수들을 실행하고, 알맞은 인자들을 넘겨줘야 합니다.
	- Subsystem 클래스들은 Facade의 존재에 대해 알지 못합니다. 그들은 커다란 시스템(library, framework)안에서 작동하며, 서로 다른 subsystem들과 직접적으로 연결되어 작동합니다.
4. 클라이언트는 서브시스템 객체를 직접적으로 부르는 것이 아니라 Facade를 대신 사용합니다.


## 활용도
- 복잡한 서브시스템에 대한 제한적이지만 직관적인 인터페이스가 존재할 때 사용
	- 주로 서브시스템들은 시간이 지날수록 복잡해 집니다. 디자인 패턴들을 적용하는 것조차도 클래스들을 추가로 만들어 냅니다. 
	- 서브시스템은 활용도가 높아지고 여러 상황에서 사용될 수 있지만, 그러한 기능들을 사용하기 위해 클라이언트로 부터 요구되는 설정들은 더욱 더 커집니다. 
	- Facade는 이러한 문제들을 클라이언트가 가장 자주 사용되는 기능들에 대한 지름길을 제공해 해결합니다. 
- 서브시스템을 계층 구조로 변경하고 싶을 때 Facade를 사용합니다.
	- 서브시스템의 각 단계에 대한 진입 지점을 facade로 만들 수 있습니다. 서브시스템간의 통신을 facade로 제한해 결합도를 낮춥니다.
	- 예를 들어, 비디오 전환 프레임워크를 두개의 레이어로 나눌 수 있습니다. : video와 audio 계층으로 나누고, 각 계층은 facade를 통해서 통신합니다.

## 구현 방법
1. 현재 있는 서브시스템이 제공하는 것보다 간단한 인터페이스를 제공하는 것이 가능한지 확인. 만약 그러한 인터페이스를 만들었을 때 클라이언트 코드를 서브시스템의 클래스로부터 독립적이게 한다면 맞게 하고 있는 것입니다.
2. 새로 만든 interface를 새로운 facade 클래스로 작성합니다. Facade는 클라이언트로부터 온 요청을 알맞은 서브시스템의 객체로 전달해줘야 합니다. Facade는 (클라이언트가 하고 있지 않다면) 서브시스템의 생성과 라이프 사이클을 담당합니다.
3. Facade패턴을 최대한 활용하기 위해, 모든 클라이언트 코드들이 서브시스템과는 facade를 통해서만 통신하게 합니다. 결과적으로, 클라이언트 코드는 서브시스템의 변화에 대해 완전히 보호됩니다. 
	- 만약 서브시스템이 업데이트/업그레이드 된다면, 클라이언트 코드는 수정될 필요 없이 facade만 수정하면 됩니다.
4. 만약 facade가 너무 커진다면, 그 중 일부를 새로운 facade 클래스로 만들어 보는 것도 가능합니다.

## 장/단점
- 장점: 코드를 서브시스템의 복잡함으로부터 격리시킬 수 있다.
- 단점: facade가 어플리케이션의 모든 클래스와 결합된 "만능 객체"가 될 수 있다.

## 다른 패턴들과의 관계
- Facade는 기존의 객체들에 대한 새로운 인터페이스를 정의하고, Adpater는 이미 존재하는 interface를 사용가능하게 한다. Adapter는 대채로 하나의 객체를 감싸고, Facade는 서브시스템의 객체들 전체와 엮인다.
- 오직 서브시스템의 객체들이 어떻게 생성되는 지 클라이언트 코드로 숨시고 싶을 때는 Abstract Factory가 Facade로 대체 사용될 수 있다.
- Flyweight은 작은 객체들을 만드는 방법들을 보여주고, Facade는 하나의 객체가 모든 서브시스템을 표현하는지 보여준다.
- Facade와 Mediator는 비슷한 일을 한다: 강하게 결합된 클래스들 사이의 연결을 정돈시키려 한다.
	- Facade는 서브시스템의 객체들에 대한 간단한 인터페이스를 제공하지만, 새로운 기능을 제공하지는 않는다. 서브시스템 자체는 facade의 존재에 대해 알지 못하고, 서브시스템 내의 객체들은 서로와 직접적으로 통신이 가능하다.
	- Mediator은 시스템의 요소들 간의 통신을 중앙화 한다. 요소들은 Mediator에 대해서만 알고, 다른 요소들과는 직접적으로 통신하지 않는다.
- Facade 클레스는 대부분의 상황에 하나만 있으면 되므로 Singleton으로 변환될 수 있다.
- Facade는 Proxy와 복잡한 것을 클라이언트로부터 숨기는 면에서 비슷하다. Facade와는 달리, Proxy는 Proxy가 제공하는 서비스 객체와 같은 인터페이스를 가지고 있어서 교체될 수 있다.

## Code Example
complexLibrary/VideoFile.java
```java
package blog.dskim.designPatterns.facade.complexLibrary;

public class VideoFile {
    private String name;
    private String codecType;

    public VideoFile(String name) {
        this.name = name;
        this.codecType = name.substring(name.indexOf(".") + 1);
    }

    public String getCodecType() {
        return codecType;
    }

    public String getName() {
        return name;
    }
}
```
---
complexLibrary/Codec.java
```java
package blog.dskim.designPatterns.facade.complexLibrary;

public interface Codec {
}
```
---
complexLibrary/MPEG4CompressionCodec.java
```java
package blog.dskim.designPatterns.facade.complexLibrary;

public class MPEG4CompressionCodec implements Codec{
    public String type = "mp4";
}
```
---
complexLibrary/OggCompressionCodec.java
```java
package blog.dskim.designPatterns.facade.complexLibrary;

public class OggCompressionCodec implements Codec{
    public String type = "ogg";
}
```
---
complexLibrary/CodecFactory.java
```java
package blog.dskim.designPatterns.facade.complexLibrary;

public class CodecFactory {
    public static Codec extract(VideoFile file) {
        String type = file.getCodecType();
        if (type.equals("mp4")) {
            System.out.println("CodecFactory: extracting mpeg audio...");
            return new MPEG4CompressionCodec();
        } else {
            System.out.println("CodecFactory: extracting ogg audio...");
            return new OggCompressionCodec();
        }
    }
}
```
---
complexLibrary/BitrateReader.java
```java
package blog.dskim.designPatterns.facade.complexLibrary;

public class BitrateReader {
    public static VideoFile read(VideoFile file, Codec codec) {
        System.out.println("BitrateReader: reading file...");
        return file;
    }

    public static VideoFile convert(VideoFile buffer, Codec codec) {
        System.out.println("BitrateReader: writing file...");
        return buffer;
    }
}
```
---
complexLibrary/AudioMixer.java
```java
package blog.dskim.designPatterns.facade.complexLibrary;

import java.io.File;

public class AudioMixer {
    public File fix(VideoFile result) {
        System.out.println("AudioMixer: mixing audio...");
        return new File("tmp");
    }
}
```
---
facade/VideoConversionFacade.java
```java
package blog.dskim.designPatterns.facade.facade;

import blog.dskim.designPatterns.facade.complexLibrary.*;

import java.io.File;

public class VideoConversionFacade {
    public File convertVideo(String fileName, String format) {
        System.out.println("VideoConversionFacade: conversion started.");
        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals("mp4")) {
            destinationCodec = new OggCompressionCodec();
        } else {
            destinationCodec = new MPEG4CompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File result = (new AudioMixer()).fix(intermediateResult);
        System.out.println("VideoConversionFacade: conversion completed.");
        return result;
    }
}
```
---
Demo.java
```java
package blog.dskim.designPatterns.facade;

import blog.dskim.designPatterns.facade.facade.VideoConversionFacade;

import java.io.File;

public class Demo {
    public static void main(String[] args) {
        // some other business logics: login, recording videos...

        VideoConversionFacade converter = new VideoConversionFacade();
        File mp4Video = converter.convertVideo("youtubevideo.ogg", "mp4");

        // other business logics: editing, uploading...
    }
}
```
---
Output
```
> Task :Demo.main()
VideoConversionFacade: conversion started.
CodecFactory: extracting ogg audio...
BitrateReader: reading file...
BitrateReader: writing file...
AudioMixer: mixing audio...
VideoConversionFacade: conversion completed.
```

---
UglyDemo.java
```java
public class UglyDemo {
    public static void main(String[] args) {

        // some other business logics: login, recording videos...

        System.out.println("conversion started.");
        String fileName = "youtubevideo.ogg";
        String format = "ogg";

        VideoFile file = new VideoFile(fileName);
        Codec sourceCodec = CodecFactory.extract(file);
        Codec destinationCodec;
        if (format.equals("mp4")) {
            destinationCodec = new OggCompressionCodec();
        } else {
            destinationCodec = new MPEG4CompressionCodec();
        }
        VideoFile buffer = BitrateReader.read(file, sourceCodec);
        VideoFile intermediateResult = BitrateReader.convert(buffer, destinationCodec);
        File convertedVideo = (new AudioMixer()).fix(intermediateResult);
        System.out.println("conversion completed.");

        // other business logics: editing, uploading...

    }
}
```